# 语言

## C#

### 值类型和引用类型的区别
- **内存位置**：值类型通常在栈上分配，作为引用类型的字段或发生装箱时也会位于堆上；引用类型实例分配在堆上，变量持有对象地址。
- **数据表现**：值类型变量直接持有数据；引用类型变量持有对象引用。
- **继承体系**：值类型继承自 `System.ValueType`，引用类型继承自 `System.Object`。
- **传递方式**：值类型默认按值传递，引用类型按引用传递。
- **性能倾向**：值类型避免堆分配与 GC，频繁装箱会抵消优势；引用类型需堆分配并受 GC 管理。
- **典型类型**：值类型包括 `byte`、`int`、`long`、`float`、`double`、`decimal`、`char`、`bool` 以及 `struct`；引用类型包括 `string` 与所有 `class`，实例需 `new` 分配堆内存。

### 拆箱与装箱
- **装箱 (boxing)**：将值类型转换为引用类型（通常为 `object`）。
- **拆箱 (unboxing)**：将引用类型还原为值类型。
装箱/拆箱为值类型与引用类型搭建桥梁，但频繁装箱会产生额外 GC 压力。

### 数组、ArrayList、List 的区别
- 参考：<https://www.cnblogs.com/newcapecjmc/p/6970220.html>

### HashTable、Dictionary、ConcurrentDictionary 的区别
- 参考：<https://www.cnblogs.com/yinrq/p/5584885.html>

### List/Dictionary 源码剖析
- 参考：<https://zhuanlan.zhihu.com/p/634380627>

### 抽象类与接口
**共同点**：均不能直接实例化，实现/继承后方可创建对象。

**差异**：
- 接口只定义契约，不含状态；C# 8+ 允许默认接口实现但仍不可持有实例字段。抽象类可包含字段、已实现的方法与抽象方法。
- 接口通过 `:` 由类或结构体实现；抽象类通过继承扩展。
- 抽象类强调“is-a”，接口强调能力/行为“can-do”。
- 在 C# 中接口成员默认 `public`，不可包含实例字段；抽象类成员可有多种可见性，抽象方法不能与 `static` 等修饰符组合。

### 选择抽象类还是接口
- 行为跨越多种不相关类：优先接口。
- 具备共享状态或基础实现的同源类：优先抽象类。

### in / out / ref
- `in`：按引用传递但只读，调用方实参不可被修改。
- `out`：按引用传递且方法内必须赋值，调用方实参在返回后获得结果。
- `ref`：按引用传递且要求调用前已初始化，方法内可读写。

```C#
class Test
{
    static void Main(string[] args)
    {
        InOutRef test = new InOutRef();
        string outString = "10"; // out 在函数外可先赋值
        string refString = "1";  // ref 必须先初始化
        test.Test(1, out outString, ref refString);
    }
}

class InOutRef
{
    public void Test(in int inTest, out string outTest, ref string refTest)
    {
        outTest = "10"; // out 在方法内必须赋值
    }
}
```

### C# 反射
- 基础概念：<https://zhuanlan.zhihu.com/p/41282759>

### 委托
- 综述：<https://www.cnblogs.com/oneweek/p/11236811.html>

### 字符串复制
- 通过 `string.Copy` 或 `CopyTo` 进行浅复制；`CopyTo` 需指定起始位置、目标数组与长度。

### const 与 readonly 的使用
- `const`：编译期常量，类级别，声明即需初始化，不可与 `static` 叠加。
- `readonly`：运行期只读字段，可在声明或构造函数中初始化，适用于任何类型，可与 `static` 组合。
- 只有内置数值/字符串等可声明为 `const`；复杂类型使用 `readonly`。

### 函数能否返回引用
- 引用返回可以避免大对象拷贝并提升可读性。
- 返回的引用对象必须在调用前已存在，禁止返回局部变量的引用。
- 需要只读时可返回 `ref readonly` 或加 `const` 语义。

### 结构体与类的区别
- 类为引用类型，结构体为值类型。
- 结构体不支持继承（仅可实现接口）。
- 结构体不能声明无参默认构造函数。

### async/await 与 Task.Run 的区别与使用场景
- `async/await` 是语法糖，核心是生成状态机，把**异步等待**写成同步风格；`Task.Run` 是把代码扔到线程池后台执行，解决**CPU 密集**工作阻塞主线程的问题。
- IO 密集（如网络、磁盘、UnityWebRequest）优先使用原生异步 API + `await`，避免无意义的线程切换；CPU 密集（如大数据解析）才考虑 `Task.Run` 或 Job System。
- Unity 主线程 API 只能在主线程调用，后台线程完成后需调度回主线程（如通过 `UnityMainThreadDispatcher`、`SynchronizationContext.Post`）。

### lock、Monitor、Interlocked 该如何选择
- `lock` 是对 `Monitor.Enter/Exit` 的语法糖，适合保护少量共享状态的临界区；尽量锁粒度小、锁对象私有且不可被外部引用。
- `Monitor` 提供更细节的 `TryEnter`、`Pulse/Wait` 等同步原语，适合需要等待/通知模型的场景。
- `Interlocked` 适合简单自增/交换/比较交换的无锁场景，避免锁开销，但只适用于单个数值或指针的原子操作。

### 何时选择 struct，何时避免
- 结构体适合**小而简单、不可变**的数据（如少量字段的数学类型），减少堆分配与 GC。
- 避免用于：需要继承/多态、大对象（>16 字节）、频繁装箱或放入非泛型集合、需要可变共享状态的场景。

### 常用数据结构时间复杂度
![](img/时间复杂度.png)

### 闭包
**概念**：内层函数可捕获并访问外层函数的变量，即使外层已返回，但访问到的是变量的最新值。

**常见形成方式**：
- 嵌套定义的函数或匿名函数。
- 将函数作为参数或返回值传递。
- .NET 中委托/匿名方法可构成闭包，便于在异步或回调中保留上下文。

### CLR 与 GC
**基本概念**

- CLR: Common Language Runtime, 公共语言运行时，是一种可以支持多种语言的运行时，其基本的核心功能包含:
    - 内存管理
    - 程序集加载和卸载
    - 类型安全
    - 异常处理
    - 线程同步

![f46ea4a64f73e366de414ff73fc9b178.png](img/4888_1.png)
- 托管模块的基本组成:
    - PE32/PE32+(64位)
    - CLR头
    - 元数据
    - IL代码(托管代码)
    
- 引用类型和值类型
    - 这部分略过，基本都有相关的认识，本质是看其分配的内存位于内存堆上还是栈上。
    - 每个进程会分配一个对应的进程堆，这就是我们常说的程序内存申请区域，不同进程是不会有交叉的。在堆上还是在栈上进行内存分配，是没有速度差异的，都很快。
    
- 垃圾回收器(Garbage Collector)
    - 在CLR中的自动内存管理，就会使用垃圾回收器来执行内存管理，其会定时执行，或者在申请内存分配是发现内存不足时触发执行，也可以手动触发执行(System.GC.Collect)
    - 垃圾回收的几种基本算法
        - 标记清除算法(Mark-Sweep)关键点是，清除后，并不会执行内存的压缩
        - 复制算法(Copying) 内存等额划分，每次执行垃圾回收后，拷贝不被回收的内存到没有被使用的内存块，自带内存压缩，弊端是内存浪费大(每次只能使用部分，预留部分给拷贝使用)
        - 标记整理算法(Mark-Compact)关键点，清除后，会执行内存压缩，不会有内存碎片
        - 分代收集算法(Generational Collection)对内存对象进行分代标记，避免全量垃圾回收带来的性能消耗。下文会详细讲解。

**垃圾回收模型**

- 垃圾回收的目的
    - 缘由： 内存是有限的，为了避免内存溢出，需要清理无效内存
- 触发时机
    - 申请分配内存时内存不足(本身不足或者内存碎片过多没有足够大小的内存片)
    - 强制调用System.GC.Collect
    - CLR卸载应用程序域(AppDomain)
    - CLR正在关闭(后面2种在进程运行时不会触发)
- 垃圾回收的流程
    - GC准备阶段 暂停进程中的所有线程，避免线程在CLR检测根期间访问堆内存
    - GC的标记阶段 首先，会默认托管堆上所有的对象都是垃圾(可回收对象)，然后开始遍历根对象并构建一个由所有和根对象之间有引用关系的对象构成的对象图，然后GC会挨个遍历根对象和其引用对象，如果根对象没有任何引用对象(null)GC会忽略该根对象。对于含有引用对象的根对象以及其引用对象，GC将其纳入对象图中，如果发现已经处于对象图中，则换一个路径遍历，避免无限循环。PS： 所有的全局和静态对象指针是应用程序的根对象。
    - 垃圾回收阶段 完成遍历操作后，对于没有被纳入对象图中的对象，执行清理操作
    - 碎片整理阶段 如果垃圾回收算法包含这个阶段，则会对剩下的保留的对象进行一次内存整理，重新归类到堆内存中，相应的引用地址也会对应的整理，避免内存碎片的产生。
    
![c9080d88c233905b46803105fc1ba3d4.png](img/4890_1.png)

- 分代垃圾回收的过程
    - 分代的基本设计思路:
        - 对象越新，生命周期越短，反之也成立
        - 回收托管堆的一部分，性能和速度由于回收整个托管堆
    - 基本的分代: 0/1/2：
        - 0代: 从未被标记为回收的新分配对象
        - 1代: 上一次垃圾回收中没有被回收的对象
        - 2代: 在一次以上的垃圾回收后任然未被回收的对象
    - 低一代的GC触发，移动到高一代后，未必会触发高一代的GC，只有高一代的内存不足时才会触发高一代的GC
    - 不同代的自动GC频率是可以设置的，一般0:1:2的频率为100：10：1

- 操作图解释分代的过程:

![c2946fc2ec499605030049306eef61c0.png](img/4892_1.png)

![93715a475185a503e7beecd808e743e8.png](img/4894_1.png)


-  非托管对象的回收
    - 对于非托管对象的管理，不受CLR的自动内存管理操作，这部分需要借鉴CLR的自动管理或者手动执行内存回收，这就是两种非托管对象的管理方式: Finalize和Dispose
    - 非托管资源: 原始的操作系统文件句柄，原始的非托管数据库连接，非托管内存或资源

- Finalize
    - System.Object定义了Finalize()虚方法，不能用override重写，其写法类似c++的析构函数:
``` C#
class Finalization{
    ~Finalization()
    {
        //这里的代码会进入Finalize方法
        Console.WriteLine("Enter Finalize()");
    }
}
```

- 转换的IL:

    ![6e65ed60af2d7c62490f0dc834fbf47f.png](img/4896_1.png)
    - 基类方法放入到Finally中，其本质还是交给GC进行处理，只是其执行的时间不确定，是在GC完后在某个时间点触发执行Finalize方法，使用这个方法的唯一好处就是: 非托管资源是必然会被释放的。



- IDisposable
    - 继承了该接口，则需要实现Disposable接口，需要手动调用，这就确保了回收的及时性，对应的问题是如果不显示调用Dispose方法，则这部分非托管资源是不会被回收的。
    - c#中的using关键字，转换成IL语句，就是内部实现了IDispoable方法，最终的try/finally中，会在finally中调用dispose方法。

- Unity中的C# GC
    - 目前unity2018.4还是 Boehm–Demers–Weiser garbage collector， unity2019.1 中已经开始引入: Incremental Garbage Collection增量式垃圾回收功能,
    - 相关链接: https://www.gamefromscratch.com/post/2018/11/27/unity-add-incremental-garbage-collection-in-20191.aspx


## Lua

### Lua 元表

菜鸟教程:https://www.runoob.com/lua/lua-metatables.html

lua的元表以及多继承:https://www.jianshu.com/p/3eaa69a6d0a2


### Lua GC

**基本数据结构**
lua的基本数据结构: union + type
``` lua
typedef union Value{
    GCObject* gc;   //gc object
    void* p;       // light userdata
    int b;         // booleans
    lua_CFunction f; // light c functions
    lua_Integer i;   //integer number 5.1为double，5.3为long long 8个字节
    lua_Number n;   // double number 5.3 为double 8个字节
} Value;

struct lua_Value{
    Value value_;
    int tt_;
} TValue;
```
对于所有的需要被GC的对象，都会放在GCObject组成的链表中


**GC算法和流程**

1.双色标记清除算法
在Lua5.0中的GC，是一次性不可被打断的操作，执行的算法是Mark-and-sweep算法，在执行GC操作的时候，会设置2种颜色，黑色和白色，然后执行gc的流程，大体的伪代码流程如下:



``` c
每个新创建的对象为白色

//初始化阶段
遍历root链表中的对象，并将其加入到对象链表中    

//标记阶段   
当前对象链表中还有未被扫描的元素:    
    从中取出对象并将其标记为黑色   
    遍历这个对象关联的其他所有对象: 
        标记为黑色
        
//回收阶段
遍历所有对象:   
    如果为白色:   
        这些对象没有被引用，则执行回收
    否则: 
        这些对象仍然被引用，需要保留
```
整个过程是不能被打断的，这是为了避免一种情况：
如果可以被打断，在GC的过程中新创建一个对象
那么如果标记为白色，此时处于回收阶段，那么这个对象没有被扫描就会被回收；
如果标记为黑色，此时处于回收阶段，那么这个对象没有被扫描就会被保留
两种情况都不适合，所以只有让整个过程不可被打断，带来的问题就是造成gc的时候卡顿

**三色标记清除算法**
虽然是三色，本质是四色，颜色分为三种:
- 白色: 当前对象为待访问状态，表示对象还未被gc标记过，也就是对象创建的初始状态； 同理，如果在gc完成后，仍然为白色，则说明当前对象没有被引用，则可以被清除回收
- 灰色: 当前对象为待扫描状态，当前对象已经被扫描过，但是其引用的其他对象没有被扫描
- 黑色: 当前对象已经扫描过，并且其引用的其他对象也被扫描过

其流程伪代码:
``` c
每个新创建的对象为白色

//初始化阶段   
遍历root阶段中引用的对象，从白色设置为灰色，并放入到灰色节点列表中   

//标记阶段    
当灰色链表中还有未被扫描的元素:    
    从中去除一个对象并将其标记为黑色   
    遍历这个对象关联的其他所有对象:   
        如果是白色:
            标记为灰色，并加入灰色链表中   
            
//回收阶段  
遍历所有对象:   
    如果为白色: 
        这些对象没有被引用，需要被回收
    否则:
        重新加入对象链表中等待下次gc   
整个标记过程是可以被打断的，被打断后回来只需要接着执行标记过程即可，回收阶段是不可被打断的。
```
如何解决在标记阶段之后创建的对象为白色的问题?
分裂白色为两种白色，一种为当前白色 currentwhite， 一种为非当前白色 otherwhite，新创建的对象都为otherwhite，则在执行回收的时候，如果为otherwhite则不执行回收操作，等待下次gc的时候，会执行白色的轮换，则新创建的对象会进入下一轮gc。

**lua gc的一些关键点**
1.初始化阶段的操作原理
以前我一直理解这个root就是将gcobject的链表进行转换到灰色链表中，其实并不是，而是去对当前虚拟机中的mainthread表, G表， registry表进行操作，其函数为:
``` c
static void markroot(lua_State * L)
{
    global_State *g = G(L);
    g->gray = NULL;
    g->grayagain = NULL;
    g->weak = NULL;
    //标记几个入口
    markobject(g, g->mainthread);
    markvalue(g, gt(g->mainthread));
    markvalue(g, registry(L));
    markmt(g);
    g->gcstate = GCSpropagte;
}
```
markobject/markvalue都是将对象从白色标记为灰色，所以这里面还有效的数据，就会最终进行扫描标记，如果最终不是白色，则会被保留，而执行回收操作的时候，是对gclist进行操作的，只要是currentwhite，那么就是可以被回收的。

2.对于中途创建的对象的颜色处理
这儿会分为两种，前向操作和后退操作:
- 前向操作: 新创建对象为白色，被一个黑色对象引用，则将当前新创建对象标记为灰色
- 后退操作: 新创建对象为白色，被黑色对象引用，该黑色对象退回到灰色，塞入到grayagain表中，后续一次性扫描处理

对大部分数据，都是前向操作，对于table类型数据，则如果其新创建对象，该table会回退到灰色塞入到grayagain表中。
本质没区别，主要是table属于频繁操作的对象，如果反复将table中新创建的对象都设置成灰色，则灰色链表会容易变得很大，所以为了提高性能，就将table塞入到grayagain表中，后续一次性处理即可。



### Lua pairs和ipairs的区别
lua中pairs和ipairs的区别:https://blog.csdn.net/Memoryuuu/article/details/85067701





